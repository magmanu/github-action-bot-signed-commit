name: "github-actions-bot-signed-commit"
description: Sign commits using GitHub App or GITHUB_TOKEN. Compatible with large and binary files.
branding:
  color: "green"
  icon: "award"

inputs:
  TOKEN:
    description: "If signing commits with Github Apps, provide the App token. Else, it defults to GITHUB_TOKEN."
    required: false
    type: string
    default: ${{ github.token }}
  TARGET_OWNER:
    description: "The repository owner (user/org)"
    required: false
    type: string
    default: ${{ github.repository_owner }}
  TARGET_REPO:
    description: "The repository where the signed commits will be pushed to."
    required: false
    type: string
    default: ${{ github.event.repository.name }}
  TARGET_REF:
    description: "The branch where the signed commits will be pushed to."
    required: false
    type: string
    default: ${{ github.head_ref || github.ref_name }}
  FILE_LIST:
    description: "Path to a text file containing the list of file paths to be committed. E.g.: subdir/file_paths.txt"
    required: true
    type: string
  WORKING_DIR:
    description: "The working directory where the action will run."
    required: false
    type: string
    default: ${{ github.workspace }}
  IS_DRY_RUN:
    description: "If set to true, the action will push the commits and leave them orphans (the head won't move.)"
    required: false
    type: boolean
    default: false
outputs:
  sha:
    description: "SHA of the verified commit"
    value: ${{ steps.sign_and_push.outputs.sha }}

runs:
  using: "composite"
  steps:
    - name: Sign and push commits
      shell: bash
      id: sign_and_push
      env:
        TOKEN: ${{ inputs.token }}
        TARGET_OWNER: ${{ github.repository_owner }}
        TARGET_REPO: ${{ github.event.repository.name }}
        TARGET_REF: ${{ inputs.TARGET_REF }}
        FILE_LIST: ${{ inputs.FILE_LIST }}
        IS_DRY_RUN: ${{ inputs.IS_DRY_RUN }}
      working-directory: ${{ inputs.WORKING_DIR }}
      run: |
        #!/bin/bash
        set -euo pipefail

        API="https://api.github.com/repos/$TARGET_OWNER/$TARGET_REPO"
        if [[ ! -f "$FILE_LIST" ]]; then
          echo "List of files to commit not found: $FILE_LIST"
          exit 1
        else
          echo "::debug::List of files to commit found: $FILE_LIST"
        fi

        echo "::group::Files to commit"
        cat "$FILE_LIST"
        echo "::endgroup::"

        tree_items_file=$(mktemp)
        echo "[" > "$tree_items_file"
        first=1

        while IFS= read -r file_path; do

          if [[ ! -f "$file_path" ]]; then
            echo "File not found: $file_path"
            exit 1
          fi

          mime_type=$(file --mime-type -b "$file_path")
          echo "::debug::MIME type: $mime_type"

          is_binary="false"
          [[ ! "$mime_type" =~ text ]] && is_binary="true"

          if [[ "$is_binary" == "true" ]]; then
            echo "Processing binary file: $file_path"
            blob_sha=$(base64 -w 0 "$file_path" \
              | jq -Rs --arg encoding "base64" '{content: ., encoding: $encoding}' \
              | curl -s -X POST \
                  -H "Authorization: token $TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "$API/git/blobs" \
                  -d @- | jq -r '.sha')

            tree_entry=$(jq -n \
                --arg path "$file_path" \
                --arg mode "100644" \
                --arg type "blob" \
                --arg sha "$blob_sha" \
                '{path: $path, mode: $mode, type: $type, sha: $sha}')
          else
            echo "Processing text file: $file_path"
            temp_content=$(mktemp)
            cat "$file_path" > "$temp_content"
            tree_entry=$(jq -n \
                --arg path "$file_path" \
                --arg mode "100644" \
                --arg type "blob" \
                --rawfile content "$temp_content" \
                '{path: $path, mode: $mode, type: $type, content: $content}')
            rm -f "$temp_content"
          fi

          if [ $first -eq 1 ]; then
            echo "$tree_entry" >> "$tree_items_file"
            first=0
          else
            echo ",$tree_entry" >> "$tree_items_file"
          fi
        done < "$FILE_LIST"

        echo "]" >> "$tree_items_file"

        total_items=$(jq length "$tree_items_file")
        batch_size=100
        batches=$(( (total_items + batch_size - 1) / batch_size ))

        echo "Get the latest commit"
        latest_commit=$(curl -s -H "Authorization: token $TOKEN" \
            "$API/git/refs/heads/$TARGET_REF" \
            | jq -r '.object.sha')

        echo "Get the tree of the latest commit"
        base_tree=$(curl -s -H "Authorization: token $TOKEN" \
            "$API/git/commits/$latest_commit" \
            | jq -r '.tree.sha')

        parent_commit="$latest_commit"

        for ((batch=0; batch<batches; batch++)); do
            echo "::group::Performing signed commit. Batch $((batch + 1)) of $batches"
            start=$((batch * batch_size))
            end=$((start + batch_size - 1))
            batch_file=$(mktemp)

            # Extract a batch of tree items
            jq ".[$start:$((end+1))]" "$tree_items_file" > "$batch_file"

            echo "Building tree"
            tree_json=$(jq -n \
              --arg base_tree "$base_tree" \
              --slurpfile tree_items "$batch_file" \
              '{base_tree: $base_tree, tree: $tree_items[0]}')

            echo "Create new tree with GH API" 
            new_tree_sha=$(echo "$tree_json" | \
              curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                -X POST "$API/git/trees" --data-binary @- | jq -r '.sha')

            echo "Create commit with GH API (will be signed)"
            commit_json=$(jq -n \
              --arg msg "Batch deploy $(date --utc +'%Y-%m-%dT%H:%M:%SZ')" \
              --arg tree "$new_tree_sha" \
              --arg parent "$parent_commit" \
              '{message: $msg, tree: $tree, parents: [$parent]}')
            parent_commit=$(echo "$commit_json" | \
              curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                -X POST "$API/git/commits" --data-binary @- | jq -r '.sha')

            echo "Update base_tree for next batch"
            base_tree="$new_tree_sha"
            rm "$batch_file"
            echo "::endgroup::"
        done

        if [[ "${IS_DRY_RUN}" == "true" ]]; then
            echo "Dry run mode is enabled. The target branch head will not point to the new signed commit."
        else
            echo "Update the target branch with the new commit"
            curl -s -H "Authorization: token $TOKEN" -X PATCH \
              -d "{\"sha\":\"$parent_commit\"}" "$API/git/refs/heads/$TARGET_REF"
            echo "Target branch successfully updated with the new signed commit."
        fi

        echo "New signed commit SHA: $parent_commit"
        echo "sha=$(echo $parent_commit)" >> $GITHUB_OUTPUT
