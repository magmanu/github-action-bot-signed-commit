name: "github-actions-bot-signed-commit"
description: Sign commits using GitHub App or GITHUB_TOKEN. Compatible with large and binary files.
branding:
  color: "green"
  icon: "award"

inputs:
  TOKEN:
    description: "If signing commits with Github Apps, provide the App token. Else, it defults to GITHUB_TOKEN."
    required: false
    type: string
    default: ${{ github.token }}
  TARGET_OWNER:
    description: "The repository owner (user/org)"
    required: false
    type: string
    default: ${{ github.repository_owner }}
  TARGET_REPO:
    description: "The repository where the signed commits will be pushed to."
    required: false
    type: string
    default: ${{ github.event.repository.name }}
  TARGET_REF:
    description: "The branch where the signed commits will be pushed to."
    required: false
    type: string
  FILE_LIST:
    description: "Path to a text file containing the list of file paths to be committed. E.g.: subdir/file_paths.txt"
    required: false
    type: string
  WORKING_DIR:
    description: "The working directory where the action will run."
    required: false
    type: string
    default: ${{ github.workspace }}
  IS_DRY_RUN:
    description: "If set to true, the action will push the commits but leave them orphans (the head won't move.)"
    required: false
    type: boolean
    default: false
  SHOULD_CREATE_NEW_BRANCH:
    description: "If set to true, the action will create the target branch if it doesn't exist."
    required: false
    type: boolean
    default: true
  COMMIT_MESSAGE:
    description: "The commit message to use for the signed commits. Your message will be suffixed with a UTC human-friendly timestamp."
    required: false
    type: string
    default: "Signed commit"

outputs:
  sha:
    description: "SHA of the verified commit"
    value: ${{ steps.sign_and_push.outputs.sha }}

runs:
  using: "composite"
  steps:
    - name: Create branch if it doesn't exist
      if: ${{ inputs.SHOULD_CREATE_NEW_BRANCH == 'true' }}
      shell: bash
      id: create_branch
      env:
        TOKEN: ${{ inputs.TOKEN }}
        TARGET_OWNER: ${{ inputs.TARGET_OWNER }}
        TARGET_REPO: ${{ inputs.TARGET_REPO }}
        TARGET_REF: ${{ inputs.TARGET_REF }}
        GH_TOKEN: ${{ github.token }}
      run: |
        #!/bin/bash
        set -euo pipefail

        branch_exists=$(curl -s -H "Authorization: token $TOKEN" \
          "https://api.github.com/repos/$TARGET_OWNER/$TARGET_REPO/git/refs/heads/$TARGET_REF" | jq -r '.ref // empty')

        if [[ -n "$branch_exists" ]]; then
          echo "Branch '$TARGET_REF' already exists."
          exit 0
        fi

        DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef | jq -r '.defaultBranchRef.name')

        DEFAULT_BRANCH_SHA=$(gh api \
          "repos/$TARGET_OWNER/$TARGET_REPO/git/ref/heads/$DEFAULT_BRANCH" \
          --jq '.object.sha')

        if [ -z "$DEFAULT_BRANCH_SHA" ]; then
          echo "Error: Could not retrieve SHA of the default branch '$DEFAULT_BRANCH'."
          exit 1
        fi

        echo "Creating remote branch '$TARGET_REF' from default branch '$DEFAULT_BRANCH')"

        gh api \
          --method POST \
          -H "Accept: application/vnd.github+json" \
          "/repos/$TARGET_OWNER/$TARGET_REPO/git/refs" \
          -f "ref=refs/heads/$TARGET_REF" \
          -f "sha=$DEFAULT_BRANCH_SHA"

        if [ $? -eq 0 ]; then
          echo "Remote branch '$TARGET_REF' created successfully on GitHub!"
          echo "View it here: https://github.com/{owner}/{repo}/tree/$TARGET_REF"
        else
          echo "Failed to create remote branch '$TARGET_REF'."
        fi

    - name: Sign and push commits
      shell: bash
      id: sign_and_push
      env:
        TOKEN: ${{ inputs.token }}
        TARGET_OWNER: ${{ github.repository_owner }}
        TARGET_REPO: ${{ github.event.repository.name }}
        TARGET_REF: ${{ inputs.TARGET_REF }}
        FILE_LIST: ${{ inputs.FILE_LIST }}
        IS_DRY_RUN: ${{ inputs.IS_DRY_RUN }}
        COMMIT_MESSAGE: ${{ inputs.COMMIT_MESSAGE }}
      working-directory: ${{ inputs.WORKING_DIR }}
      run: |
        #!/bin/bash
        set -euo pipefail

        API="https://api.github.com/repos/$TARGET_OWNER/$TARGET_REPO"
        if [[ ! -f "$FILE_LIST" ]]; then
          echo "List of files to commit not found: $FILE_LIST"
          exit 1
        else
          echo "::debug::List of files to commit found: $FILE_LIST"
        fi

        echo "::group::Files to commit"
        cat "$FILE_LIST"
        echo "::endgroup::"

        tree_items_file=$(mktemp)
        echo "[" > "$tree_items_file"
        first=1

        while IFS= read -r file_path; do

          if [[ ! -f "$file_path" ]]; then
            echo "File not found: $file_path"
            exit 1
          fi

          mime_type=$(file --mime-type -b "$file_path")
          echo "::debug::MIME type: $mime_type"

          is_binary="false"
          [[ ! "$mime_type" =~ text ]] && is_binary="true"

          if [[ "$is_binary" == "true" ]]; then
            echo "Processing binary file: $file_path"
            blob_sha=$(base64 -w 0 "$file_path" \
              | jq -Rs --arg encoding "base64" '{content: ., encoding: $encoding}' \
              | curl -s -X POST \
                  -H "Authorization: token $TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "$API/git/blobs" \
                  -d @- | jq -r '.sha')

            tree_entry=$(jq -n \
                --arg path "$file_path" \
                --arg mode "100644" \
                --arg type "blob" \
                --arg sha "$blob_sha" \
                '{path: $path, mode: $mode, type: $type, sha: $sha}')
          else
            echo "Processing text file: $file_path"
            temp_content=$(mktemp)
            cat "$file_path" > "$temp_content"
            tree_entry=$(jq -n \
                --arg path "$file_path" \
                --arg mode "100644" \
                --arg type "blob" \
                --rawfile content "$temp_content" \
                '{path: $path, mode: $mode, type: $type, content: $content}')
            rm -f "$temp_content"
          fi

          if [ $first -eq 1 ]; then
            echo "$tree_entry" >> "$tree_items_file"
            first=0
          else
            echo ",$tree_entry" >> "$tree_items_file"
          fi
        done < "$FILE_LIST"

        echo "]" >> "$tree_items_file"

        total_items=$(jq length "$tree_items_file")
        batch_size=100
        batches=$(( (total_items + batch_size - 1) / batch_size ))

        echo "Get the latest commit"
        latest_commit=$(curl -s -H "Authorization: token $TOKEN" \
            "$API/git/refs/heads/$TARGET_REF" \
            | jq -r '.object.sha')
        if [[ -z "$latest_commit" ]]; then
            echo "Failed to retrieve the latest commit SHA for branch '$TARGET_REF'."
            if [[ "${inputs.SHOULD_CREATE_NEW_BRANCH}" == "false" ]]; then
                echo "You have prevented the creation of branches that don't exist. If you regret it, set SHOULD_CREATE_NEW_BRANCH to true"
                exit 1
            fi
        fi

        echo "Get the tree of the latest commit"
        base_tree=$(curl -s -H "Authorization: token $TOKEN" \
            "$API/git/commits/$latest_commit" \
            | jq -r '.tree.sha')

        parent_commit="$latest_commit"

        for ((batch=0; batch<batches; batch++)); do
            echo "::group::Performing signed commit. Batch $((batch + 1)) of $batches"
            start=$((batch * batch_size))
            end=$((start + batch_size - 1))
            batch_file=$(mktemp)

            # Extract a batch of tree items
            jq ".[$start:$((end+1))]" "$tree_items_file" > "$batch_file"

            echo "Building tree"
            tree_json=$(jq -n \
              --arg base_tree "$base_tree" \
              --slurpfile tree_items "$batch_file" \
              '{base_tree: $base_tree, tree: $tree_items[0]}')

            echo "Create new tree with GH API" 
            new_tree_sha=$(echo "$tree_json" | \
              curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                -X POST "$API/git/trees" --data-binary @- | jq -r '.sha')

            echo "Create commit with GH API (will be signed)"
            commit_json=$(jq -n \
              --arg msg "$COMMIT_MESSAGE $(date --utc +'%Y-%m-%dT%H:%M:%SZ')" \
              --arg tree "$new_tree_sha" \
              --arg parent "$parent_commit" \
              '{message: $msg, tree: $tree, parents: [$parent]}')
            parent_commit=$(echo "$commit_json" | \
              curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                -X POST "$API/git/commits" --data-binary @- | jq -r '.sha')

            echo "Update base_tree for next batch"
            base_tree="$new_tree_sha"
            rm "$batch_file"
            echo "::endgroup::"
        done

        if [[ "${IS_DRY_RUN}" == "true" ]]; then
            echo "Dry run mode is enabled. The target branch head will not point to the new signed commit."
        else
            echo "Update the target branch with the new commit"
            move_head=$(curl -s -H "Authorization: token $TOKEN" -X PATCH \
              -d "{\"sha\":\"$parent_commit\"}" "$API/git/refs/heads/$TARGET_REF")
            if [[ $(echo "$move_head" | jq -r '.ref // empty') == "" ]]; then
                echo "Failed to move the target branch head."
                echo "Response: $move_head"
                exit 1
            fi

            echo "Target branch successfully updated with the new signed commit."
        fi

        echo "New signed commit SHA:"
        echo "sha=$(echo $parent_commit)" | tee -a $GITHUB_OUTPUT
