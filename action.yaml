name: "github-actions-bot-signed-commit"
description: "Enable bots to sign commits in GitHub Actions"
branding:
  color: "green"
  icon: "book-open"

inputs:
  APP_ID:
    description: "If signing commits using Github Apps, provide the App ID"
    required: false
    type: string
  APP_PRIVATE_KEY:
    description: "If signing commits using Github Apps, provide the private key"
    required: false
    type: string
  DESTINATION_REF:
    description: "The branch where the signed commits will be pushed to"
    required: false
    type: string
    default: ${{ github.event.pull_request.head.ref || github.ref_name || 'main' }}
  FILE_LIST:
    description: "The path to any bash script that will be run to sign the commits. Must be in the origin ref. E.g.: my_dir/script.sh"
    required: false
    type: string

runs:
  using: "composite"
  steps:
    - name: Get GitHub App Token
      if: ${{ inputs.APP_ID && inputs.PRIVATE_KEY }}
      uses: actions/create-github-app-token@v2
      id: app-token
      with:
        app-id: ${{ inputs.APP_ID }}
        private-key: ${{ inputs.APP_PRIVATE_KEY }}
        owner: ${{ github.repository_owner }}

    - name: Sign and push commits
      shell: bash
      env:
        TOKEN: ${{ steps.app-token.outputs.token || github.token }}
        API: "https://api.github.com/repos/${{ github.repository }}"
        DESTINATION_REF: ${{ inputs.DESTINATION_REF }}
        FILE_LIST: ${{ inputs.FILE_LIST }}
      run: |
        #!/bin/bash
        set -euo pipefail

        if [[ ! -f "$FILE_LIST" ]]; then
          echo "List of files to commit not found: $FILE_LIST"
          exit 1
        fi

        echo "Files to commit:"
        cat "$FILE_LIST"

        tree_items_file=$(mktemp)
        echo "[" > "$tree_items_file"
        first=1

        while IFS= read -r -d '' file_path; do
          if [ -z "$file_path" ]; then
    echo "Skipping: file_path is empty"
    continue
  fi

  if [ ! -f "$file_path" ]; then
    echo "Skipping: file_path does not exist or is not a regular file - $file_path"
    continue
  fi

          mime_type=$(file --mime-type -b "$file_path")
          echo "MIME type: $mime_type"
          is_binary="false"
          [[ ! "$mime_type" =~ text ]] && is_binary="true"

          if [[ "$is_binary" == "true" ]]; then
            echo "Processing binary file: $file_path"
            blob_sha=$(base64 -w 0 "$file_path" \
              | jq -Rs --arg encoding "base64" '{content: ., encoding: $encoding}' \
              | curl -s -X POST \
                  -H "Authorization: token $TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "$API/git/blobs" \
                  -d @- | jq -r '.sha')

            tree_entry=$(jq -n \
                --arg path "$file_path" \
                --arg mode "100644" \
                --arg type "blob" \
                --arg sha "$blob_sha" \
                '{path: $path, mode: $mode, type: $type, sha: $sha}')
          else
            echo "Processing text file: $file_path"
            temp_content=$(mktemp)
            cat "$file_path" > "$temp_content"
            tree_entry=$(jq -n \
                --arg path "$file_path" \
                --arg mode "100644" \
                --arg type "blob" \
                --rawfile content "$temp_content" \
                '{path: $path, mode: $mode, type: $type, content: $content}')
            rm -f "$temp_content"
          fi

          if [ $first -eq 1 ]; then
            echo "$tree_entry" >> "$tree_items_file"
            first=0
          else
            echo ",$tree_entry" >> "$tree_items_file"
          fi
        done < "$FILE_LIST"

        echo "]" >> "$tree_items_file"

        total_items=$(jq length "$tree_items_file")
        batch_size=100
        batches=$(( (total_items + batch_size - 1) / batch_size ))


        echo "Get the latest commit"
        latest_commit=$(curl -s -H "Authorization: token $TOKEN" \
            "$API/git/refs/heads/$DESTINATION_REF" \
            | jq -r '.object.sha')

        echo "Get the tree of the latest commit"
        base_tree=$(curl -s -H "Authorization: token $TOKEN" \
            "$API/git/commits/$latest_commit" \
            | jq -r '.tree.sha')

        parent_commit="$latest_commit"

        for ((batch=0; batch<batches; batch++)); do
            echo "Processing batch $((batch + 1)) of $batches"
            start=$((batch * batch_size))
            end=$((start + batch_size - 1))
            batch_file=$(mktemp)

            # Extract a batch of tree items
            jq ".[$start:$((end+1))]" "$tree_items_file" > "$batch_file"

            # Build the tree JSON for this batch
            tree_json=$(jq -n \
              --arg base_tree "$base_tree" \
              --slurpfile tree_items "$batch_file" \
              '{base_tree: $base_tree, tree: $tree_items[0]}')

            # Create new tree with GH API 
            new_tree_sha=$(echo "$tree_json" | \
              curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                -X POST "$API/git/trees" --data-binary @- | jq -r '.sha')

            # Create commit with GH API (will be signed)
            commit_json=$(jq -n \
              --arg msg "Batch deploy $(date --utc +'%Y-%m-%dT%H:%M:%SZ')" \
              --arg tree "$new_tree_sha" \
              --arg parent "$parent_commit" \
              '{message: $msg, tree: $tree, parents: [$parent]}')
            parent_commit=$(echo "$commit_json" | \
              curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                -X POST "$API/git/commits" --data-binary @- | jq -r '.sha')

            # Update base_tree for next batch
            base_tree="$new_tree_sha"
            rm "$batch_file"
        done

        # Update branch ref to the last commit

        curl -s -H "Authorization: token $TOKEN" -X PATCH \
          -d "{\"sha\":\"$parent_commit\"}" "$API/git/refs/heads/$DESTINATION_REF"
        echo "Deployment completed successfully. New commit SHA: $parent_commit"

